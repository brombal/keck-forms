{"version":3,"file":"index.js","sources":["../src/util/get.ts","../src/KeckField.ts","../src/KeckFieldArray.ts","../src/KeckFieldObject.ts","../src/KeckForm.ts","../src/useForm.tsx","../src/useFormContext.ts","../src/zodValidator.ts"],"sourcesContent":["import { get as _get } from 'lodash-es';\n\nexport function get(obj: any, path: string | null | undefined): unknown {\n  return !path ? obj : _get(obj, path);\n}\n","import { atomic, derive, unwrap } from 'keck';\nimport { isEmpty, isEqual, set } from 'lodash-es';\nimport type { KeckFormBase, KeckFormState } from './KeckForm';\nimport type { ObjectOrUnknown, StringPath, ValueAtPath } from './types';\nimport { get } from './util/get';\n\nexport abstract class KeckFieldBase<\n  TFormInput extends ObjectOrUnknown,\n  TStringPath extends StringPath<TFormInput>,\n> {\n  constructor(\n    public readonly form: KeckFormBase<TFormInput, unknown>,\n    protected readonly formState: KeckFormState<TFormInput, unknown>,\n    public readonly path: TStringPath,\n  ) {}\n\n  get value(): TFormInput extends object ? ValueAtPath<TFormInput, TStringPath> : unknown {\n    return get(this.formState.values, this.path) as any;\n  }\n\n  set value(value: ValueAtPath<TFormInput, TStringPath>) {\n    atomic(() => {\n      set(this.formState.values as any, this.path, value);\n      this.form.validate();\n    });\n  }\n\n  get dirty(): boolean {\n    // Field is dirty if the value is different from the initial value\n    return derive(() => {\n      const initialValue = get(this.formState.initial, this.path);\n      return !isEqual(unwrap(initialValue), unwrap(this.value));\n    });\n  }\n\n  get touched(): boolean {\n    return derive(() => {\n      if (get(this.formState.touched, this.path)) return true;\n\n      // work up the path to see if any parent fields have allTouched\n      const path = this.path.split('.');\n      for (let i = path.length - 1; i >= 0; i--) {\n        path.pop();\n        if (get(this.formState.touched, path.join('.')) === true) return true;\n      }\n\n      return false;\n    });\n  }\n\n  set touched(value: boolean) {\n    /**\n     * Setting `touched` on a regular field will simply set the `touched` state on the field itself.\n     * If setting to false, the form state's touched tree will be cleaned up from the field to the\n     * root, eliminating entries that are empty.\n     */\n\n    atomic(() => {\n      if (value) {\n        if (this.path) {\n          this.formState.touched ||= {};\n          set(this.formState.touched, this.path, true);\n        } else this.formState.touched = true;\n        return;\n      }\n\n      if (this.path) {\n        set(this.formState.touched, this.path, false);\n        const path = this.path.split('.');\n        for (let i = path.length - 1; i >= 0; i--) {\n          path.pop();\n          if (!isEmpty(get(this.formState.touched, path.join('.')))) return;\n          if (path.length) set(this.formState.touched, path.join('.'), undefined);\n          else this.formState.touched = undefined;\n        }\n      } else this.formState.touched = false;\n    });\n  }\n\n  get errors(): string[] {\n    return (this.formState.errors[this.path] as string[]) || [];\n  }\n\n  get isValid(): boolean {\n    return derive(() => this.errors.length === 0);\n  }\n\n  // protected getFieldState(path: string = this.path, create = true): any {\n  //   let state = get(this.formState.state, path)?.[fieldState];\n  //   if (!state && create) {\n  //     state = {};\n  //     set(this.formState.state, path, { [fieldState]: state });\n  //   }\n  //   return get(this.formState.state, path)?.[fieldState];\n  // }\n\n  protected getParentPath(): string {\n    return this.path.split('.').slice(0, -1).join('.');\n  }\n}\n\nexport class KeckField<\n  TFormInput extends ObjectOrUnknown,\n  TStringPath extends StringPath<TFormInput>,\n> extends KeckFieldBase<TFormInput, TStringPath> {}\n","import { KeckFieldBase } from './KeckField';\nimport type { KeckFieldForPath, StringPath } from './types';\n\nexport class KeckFieldArray<\n  TFormInput extends object,\n  TStringPath extends StringPath<TFormInput>,\n> extends KeckFieldBase<TFormInput, TStringPath> {\n  /**\n   * Maps each field in the array to a new value by invoking the callback function.\n   */\n  map<TReturn>(\n    _callback: (\n      field: KeckFieldForPath<\n        TFormInput,\n        `${TStringPath}.${number}` extends StringPath<TFormInput>\n          ? `${TStringPath}.${number}`\n          : never\n      >,\n      index: number,\n    ) => TReturn,\n  ): TReturn[] {\n    return [];\n  }\n\n  // push(value: ValueAtPath<TFormInput, `${TStringPath}.${number}`>): void {\n  //   this.stateObserver.values[this.path].push(value);\n  // }\n  //\n  // pop(): ValueAtPath<TFormInput, `${TStringPath}.${number}`> | undefined {\n  //   return this.stateObserver.values[this.path].pop();\n  // }\n  //\n  // remove(index: number): void {\n  //   this.stateObserver.values[this.path].splice(index, 1);\n  // }\n  //\n  // shift(): ValueAtPath<TFormInput, `${TStringPath}.${number}`> | undefined {\n  //   return this.stateObserver.values[this.path].shift();\n  // }\n  //\n  // unshift(value: ValueAtPath<TFormInput, `${TStringPath}.${number}`>): void {\n  //   this.stateObserver.values[this.path].unshift(value);\n  // }\n  //\n  // swap(indexA: number, indexB: number): void {\n  //   const array = this.stateObserver.values[this.path];\n  //   [array[indexA], array[indexB]] = [array[indexB], array[indexA]];\n  // }\n  //\n  // insert(index: number, value: ValueAtPath<TFormInput, `${TStringPath}.${number}`>): void {\n  //   this.stateObserver.values[this.path].splice(index, 0, value);\n  // }\n  //\n  // clear(): void {\n  //   this.stateObserver.values[this.path] = [];\n  // }\n}\n","import { KeckFieldBase } from './KeckField';\nimport type { KeckFieldForPath, StringPath } from './types';\n\nexport class KeckFieldObject<\n  TFormInput extends object,\n  TStringPath extends StringPath<TFormInput>,\n> extends KeckFieldBase<TFormInput, TStringPath> {\n  field<TPath extends string>(\n    _path: TPath,\n  ): `${TStringPath}.${TPath}` extends StringPath<TFormInput>\n    ? KeckFieldForPath<\n        TFormInput,\n        `${TStringPath}.${TPath}` extends StringPath<TFormInput> ? `${TStringPath}.${TPath}` : never\n      >\n    : never {\n    return null as any;\n  }\n}\n","import { atomic, derive, focus, observe, peek, unwrap } from 'keck';\nimport { cloneDeep } from 'lodash-es';\nimport { KeckField } from './KeckField';\nimport { KeckFieldArray } from './KeckFieldArray';\nimport { KeckFieldObject } from './KeckFieldObject';\nimport type { FormValidatorFn, KeckFieldForPath, ObjectOrUnknown, StringPath } from './types';\nimport { get } from './util/get';\n\nexport interface KeckFormState<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> {\n  initial: TFormInput;\n  values: TFormInput;\n  output: TFormOutput | null;\n  touched: any;\n  errors: Record<string, string[]>;\n  validator: FormValidatorFn<TFormInput, TFormOutput>;\n}\n\nexport abstract class KeckFormBase<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> {\n  protected state: KeckFormState<TFormInput, TFormOutput>;\n\n  constructor(state: KeckFormState<TFormInput, TFormOutput>, callback?: () => void) {\n    this.state = observe(state, callback);\n  }\n\n  get initial() {\n    return this.state.initial;\n  }\n\n  set initial(value: TFormInput) {\n    this.state.initial = value;\n  }\n\n  get output() {\n    return this.state.output;\n  }\n\n  validate(): TFormOutput {\n    return atomic(() => {\n      this.state.errors = {};\n      this.state.output = this.state.validator(\n        cloneDeep(unwrap(this.state.values)),\n        (field, error, action = 'push') => {\n          if (!error) {\n            delete this.state.errors[field];\n            return;\n          }\n          this.state.errors[field] ||= [];\n          if (action === 'push') this.state.errors[field].push(error);\n          else if (action === 'unshift') this.state.errors[field].unshift(error);\n          else this.state.errors[field] = [error];\n        },\n      );\n      return unwrap(this.state.output);\n    });\n  }\n\n  get isValid() {\n    return derive(() => Object.keys(this.state.errors).length === 0);\n  }\n\n  /**\n   * Returns a KeckField object for the given path. This can be used to access the field value,\n   * errors, and other state.\n   *\n   * By focusing (with Keck's `focus` method) this FormObserver, you can ensure the callback is only called upon\n   * changes to specific fields in the form.\n   *\n   * @param path The path to access.\n   */\n  field<TStringPath extends StringPath<TFormInput>>(\n    path: TStringPath,\n  ): KeckFieldForPath<TFormInput, TStringPath> {\n    return peek(() => {\n      const value = get(this.state.values, path);\n      // TFormInput could be 'unknown', which KeckFieldArray and KeckFieldObject won't accept.\n      // But we know the type, and the field() method return type is explicit, so we can cast values as any to ignore TS errors.\n      if (Array.isArray(value))\n        return new KeckFieldArray(this as any, this.state as any, path as any) as KeckFieldForPath<\n          TFormInput,\n          TStringPath\n        >;\n      if (typeof value === 'object')\n        return new KeckFieldObject(this as any, this.state as any, path as any) as KeckFieldForPath<\n          TFormInput,\n          TStringPath\n        >;\n      return new KeckField(this, this.state, path) as KeckFieldForPath<TFormInput, TStringPath>;\n    });\n  }\n\n  focus(): this {\n    focus(this.state);\n    return this;\n  }\n}\n\nexport class KeckForm<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> extends KeckFormBase<TFormInput, TFormOutput> {\n  constructor(options: {\n    initial: TFormInput;\n    validate: FormValidatorFn<TFormInput, TFormOutput>;\n  }) {\n    super({\n      initial: options.initial,\n      values: cloneDeep(options.initial),\n      errors: {},\n      touched: null,\n      output: null!,\n      validator: options.validate,\n    });\n    this.state.output = this.validate();\n  }\n\n  /**\n   * Adds a callback that will be called when the form state changes. This returns a FormObserver\n   * object that can be used to observe specific fields in the form. E.g.:\n   *\n   * ```ts\n   * import { focus } from 'keck';\n   *\n   * const form = new KeckForm({ ... })\n   *\n   * // Add an observer callback\n   * const formObserver = form.observe(() => { console.log('form changed') });\n   *\n   * // Optional: \"focus\" the formObserver (using Keck's `focus` method) to ensure the callback is\n   * // only called upon changes to the specific properties accessed on this formObserver.\n   * // (If you don't call `focus`, the callback will be called on any change to the form state.)\n   * focus(formObserver);\n   * formObserver.field('name').value; // Access a property to observe changes to it\n   *\n   * // Changing a field value will trigger the callback:\n   * form.field('name').value = 'Jane'; // logs 'form changed'\n   * ```\n   */\n  observe(callback: () => void) {\n    return new KeckFormObserver(this, this.state, callback);\n  }\n}\n\nexport class KeckFormObserver<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> extends KeckFormBase<TFormInput, TFormOutput> {\n  constructor(\n    private ownerForm: KeckForm<TFormInput, TFormOutput>,\n    state: KeckFormState<TFormInput, TFormOutput>,\n    callback: () => void,\n  ) {\n    super(state, callback);\n  }\n}\n","import type React from 'react';\nimport { createContext } from 'react';\nimport { KeckForm } from './KeckForm';\nimport type { FormValidatorFn, GetFieldFn, ObjectOrUnknown } from './types';\n\nexport type UseFormReturn<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> = {\n  form: KeckForm<TFormInput, TFormOutput>;\n  field: GetFieldFn<TFormInput>;\n  FormProvider: React.FC<{ children: React.ReactNode[] }>;\n};\n\nexport const keckFormContext = createContext<KeckForm<unknown, unknown> | null>(null);\n\nexport function useForm<TFormInput extends object, TFormOutput extends object>(options: {\n  initial: TFormInput;\n  validate: FormValidatorFn<TFormInput, TFormOutput>;\n}): UseFormReturn<TFormInput, TFormOutput> {\n  const form = new KeckForm<TFormInput, TFormOutput>({\n    initial: options.initial,\n    validate: options.validate,\n  });\n\n  const typedContext = keckFormContext as React.Context<KeckForm<TFormInput, TFormOutput> | null>;\n\n  return {\n    form,\n    field: form.field,\n    FormProvider: ({ children }) => {\n      return <typedContext.Provider value={form}>{children}</typedContext.Provider>;\n    },\n  };\n}\n","import { useContext } from 'react';\nimport type { KeckForm } from './KeckForm';\nimport type { GetFormFieldFn, ObjectOrUnknown } from './types';\nimport { keckFormContext } from './useForm';\n\nexport type UseFormContextReturn<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> = {\n  form: KeckForm<TFormInput, TFormOutput>;\n  field: GetFormFieldFn<TFormInput>;\n};\n\nexport function useFormContext<\n  TFormInput extends ObjectOrUnknown = unknown,\n  TFormOutput extends ObjectOrUnknown = unknown,\n>(): UseFormContextReturn<TFormInput, TFormOutput> {\n  const form = useContext(keckFormContext) as KeckForm<TFormInput, TFormOutput>;\n  if (!form) {\n    throw new Error('useFormContext must be used within a FormProvider');\n  }\n  return {\n    form: form,\n    field: form.field,\n  };\n}\n","import type { z } from 'zod';\nimport type { FormValidatorFn, StringPath } from './types';\n\nexport const zodValidator = <TInput extends object, TOutput extends object>(\n  schema: z.Schema<TOutput>,\n): FormValidatorFn<TInput, TOutput> => {\n  return (values, setError) => {\n    const result = schema.safeParse(values);\n    if (result.success) return result.data;\n\n    for (const error of result.error.errors) {\n      const path = error.path.join('.');\n      setError(path as StringPath<TInput>, error.message);\n    }\n\n    return null;\n  };\n};\n"],"names":["_get","_jsx"],"mappings":"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"}