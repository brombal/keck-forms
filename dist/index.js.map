{"version":3,"file":"index.js","sources":["../src/util/get.ts","../src/KeckField.ts","../src/KeckFieldArray.ts","../src/KeckFieldObject.ts","../src/KeckForm.ts","../src/useForm.tsx","../src/useFormContext.ts","../src/zodValidator.ts"],"sourcesContent":["import { get as _get } from 'lodash-es';\n\nexport function get(obj: any, path: string | null | undefined): unknown {\n  return !path ? obj : _get(obj, path);\n}\n","import { atomic, derive, shallowCompare, unwrap } from 'keck';\nimport { isEmpty, isEqual, set } from 'lodash-es';\nimport type { KeckFieldArray } from './KeckFieldArray';\nimport type { KeckFieldObject } from './KeckFieldObject';\nimport type { KeckForm, KeckFormState } from './KeckForm';\nimport type { ObjectOrUnknown, StringPath, ValueAtPath } from './types';\nimport { get } from './util/get';\n\nexport type KeckFieldForPath<\n  TFormInput extends ObjectOrUnknown,\n  TStringPath extends StringPath<TFormInput>,\n> = TFormInput extends object\n  ? ValueAtPath<TFormInput, TStringPath> extends Array<infer _TFieldType>\n    ? KeckFieldArray<TFormInput, TStringPath>\n    : ValueAtPath<TFormInput, TStringPath> extends object\n      ? KeckFieldObject<TFormInput, TStringPath>\n      : KeckField<TFormInput, TStringPath>\n  : KeckField<TFormInput, TStringPath>;\n\n/**\n * Used to represent a KeckField with an explicit type (instead of inferring a type from a form input structure\n * and a string path).\n */\nexport type TypedKeckField<TType> = Omit<KeckFieldBase<unknown, ''>, 'value'> & { value: TType };\n\nexport abstract class KeckFieldBase<\n  TFormInput extends ObjectOrUnknown,\n  TStringPath extends StringPath<TFormInput>,\n> {\n  constructor(\n    public readonly form: KeckForm<TFormInput, unknown>,\n    protected readonly formState: KeckFormState<TFormInput, unknown>,\n    public readonly path: TStringPath,\n  ) {}\n\n  get value(): TFormInput extends object ? ValueAtPath<TFormInput, TStringPath> : unknown {\n    return get(this.formState.values, this.path) as any;\n  }\n\n  set value(value: ValueAtPath<TFormInput, TStringPath>) {\n    atomic(() => {\n      set(this.formState.values as any, this.path, value);\n      this.form.validate();\n    });\n  }\n\n  get dirty(): boolean {\n    // Field is dirty if the value is different from the initial value\n    return derive(() => {\n      const initialValue = get(this.formState.initial, this.path);\n      return !isEqual(unwrap(initialValue), unwrap(this.value));\n    });\n  }\n\n  get touched(): boolean {\n    return derive(() => {\n      if (get(this.formState.touched, this.path)) return true;\n\n      // work up the path to see if any parent fields have allTouched\n      const path = this.path.split('.');\n      for (let i = path.length - 1; i >= 0; i--) {\n        path.pop();\n        // TODO: could be more performant by starting from the top and only descending if object?\n        if (get(this.formState.touched, path.join('.')) === true) return true;\n      }\n\n      return false;\n    });\n  }\n\n  set touched(value: boolean) {\n    /**\n     * Setting `touched` on a regular field will simply set the `touched` state on the field itself.\n     * If setting to false, the form state's touched tree will be cleaned up from the field to the\n     * root, eliminating entries that are empty.\n     */\n\n    atomic(() => {\n      if (value) {\n        if (this.path) {\n          this.formState.touched ||= {};\n          set(this.formState.touched, this.path, true);\n        } else this.formState.touched = true;\n        return;\n      }\n\n      if (this.path) {\n        set(this.formState.touched, this.path, false);\n        const path = this.path.split('.');\n        for (let i = path.length - 1; i >= 0; i--) {\n          path.pop();\n          if (!isEmpty(get(this.formState.touched, path.join('.')))) return;\n          if (path.length) set(this.formState.touched, path.join('.'), undefined);\n          else this.formState.touched = undefined;\n        }\n      } else this.formState.touched = false;\n    });\n  }\n\n  get errors(): string[] {\n    return derive(() => (this.formState.errors[this.path] as string[]) || [], shallowCompare);\n  }\n\n  get isValid(): boolean {\n    return derive(() => this.errors.length === 0);\n  }\n}\n\nexport class KeckField<\n  TFormInput extends ObjectOrUnknown,\n  TStringPath extends StringPath<TFormInput>,\n> extends KeckFieldBase<TFormInput, TStringPath> {}\n","import { KeckFieldBase, type KeckFieldForPath } from './KeckField';\nimport type { StringPath } from './types';\n\nexport class KeckFieldArray<\n  TFormInput extends object,\n  TStringPath extends StringPath<TFormInput>,\n> extends KeckFieldBase<TFormInput, TStringPath> {\n  /**\n   * Maps each field in the array to a new value by invoking the callback function.\n   */\n  map<TReturn>(\n    _callback: (\n      field: KeckFieldForPath<\n        TFormInput,\n        `${TStringPath}.${number}` extends StringPath<TFormInput>\n          ? `${TStringPath}.${number}`\n          : never\n      >,\n      index: number,\n    ) => TReturn,\n  ): TReturn[] {\n    return [];\n  }\n\n  // push(value: ValueAtPath<TFormInput, `${TStringPath}.${number}`>): void {\n  //   this.stateObserver.values[this.path].push(value);\n  // }\n  //\n  // pop(): ValueAtPath<TFormInput, `${TStringPath}.${number}`> | undefined {\n  //   return this.stateObserver.values[this.path].pop();\n  // }\n  //\n  // remove(index: number): void {\n  //   this.stateObserver.values[this.path].splice(index, 1);\n  // }\n  //\n  // shift(): ValueAtPath<TFormInput, `${TStringPath}.${number}`> | undefined {\n  //   return this.stateObserver.values[this.path].shift();\n  // }\n  //\n  // unshift(value: ValueAtPath<TFormInput, `${TStringPath}.${number}`>): void {\n  //   this.stateObserver.values[this.path].unshift(value);\n  // }\n  //\n  // swap(indexA: number, indexB: number): void {\n  //   const array = this.stateObserver.values[this.path];\n  //   [array[indexA], array[indexB]] = [array[indexB], array[indexA]];\n  // }\n  //\n  // insert(index: number, value: ValueAtPath<TFormInput, `${TStringPath}.${number}`>): void {\n  //   this.stateObserver.values[this.path].splice(index, 0, value);\n  // }\n  //\n  // clear(): void {\n  //   this.stateObserver.values[this.path] = [];\n  // }\n}\n","import { KeckFieldBase, type KeckFieldForPath } from './KeckField';\nimport type { StringPath } from './types';\n\nexport class KeckFieldObject<\n  TFormInput extends object,\n  TStringPath extends StringPath<TFormInput>,\n> extends KeckFieldBase<TFormInput, TStringPath> {\n  field<TPath extends string>(\n    _path: TPath,\n  ): `${TStringPath}.${TPath}` extends StringPath<TFormInput>\n    ? KeckFieldForPath<\n        TFormInput,\n        `${TStringPath}.${TPath}` extends StringPath<TFormInput> ? `${TStringPath}.${TPath}` : never\n      >\n    : never {\n    return null as any;\n  }\n}\n","import { atomic, derive, focus, observe, peek, unwrap } from 'keck';\nimport { cloneDeep } from 'lodash-es';\nimport { KeckField, type KeckFieldForPath, type TypedKeckField } from './KeckField';\nimport { KeckFieldArray } from './KeckFieldArray';\nimport { KeckFieldObject } from './KeckFieldObject';\nimport type { ObjectOrUnknown, StringPath } from './types';\nimport { get } from './util/get';\n\nexport interface KeckFormState<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> {\n  initial: TFormInput;\n  values: TFormInput;\n  output: TFormOutput | null;\n  touched: any;\n  errors: Record<string, string[]>;\n  validator: FormValidatorFn<TFormInput, TFormOutput>;\n}\n\nexport type FormValidatorFn<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> = (\n  input: TFormInput,\n  setError: (\n    field: StringPath<TFormInput>,\n    error: string | null | undefined | false,\n    action?: 'push' | 'unshift' | 'replace',\n  ) => void,\n) => TFormOutput | null;\n\n/**\n * The public interface for the KeckForm class constructor parameters.\n */\nexport interface KeckFormOptions<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> {\n  initial: TFormInput;\n  validate: FormValidatorFn<TFormInput, TFormOutput>;\n}\n\n/**\n * The internal interface for the KeckForm class constructor parameters.\n */\nexport type KeckFormOptionsInternal<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> = KeckFormOptions<TFormInput, TFormOutput> & {\n  state: KeckFormState<TFormInput, TFormOutput>;\n};\n\nexport const state = Symbol('state');\n\n/**\n * The base class for a Keck Form, which is created by providing a state object. The state object should be a configured Keck observer.\n *\n * Note that a KeckForm is just a wrapper around an existing state object. Multiple KeckForm objects can exist that wrap\n * different Keck observers of the same underlying state object.\n */\nexport class KeckForm<TFormInput extends ObjectOrUnknown, TFormOutput extends ObjectOrUnknown> {\n  private [state]: KeckFormState<TFormInput, TFormOutput>;\n\n  /**\n   * Creates a KeckForm by providing an initial state and a validation function.\n   * @param options The initial state and validation function.\n   */\n  constructor(options: KeckFormOptions<TFormInput, TFormOutput>) {\n    const _state = (options as unknown as KeckFormOptionsInternal<TFormInput, TFormOutput>).state;\n    if (_state) {\n      this[state] = _state;\n    } else {\n      this[state] = observe({\n        initial: options.initial,\n        values: cloneDeep(options.initial),\n        errors: {},\n        touched: null,\n        output: null!,\n        validator: options.validate,\n      });\n      this.validate();\n    }\n  }\n\n  get initial() {\n    return this[state].initial;\n  }\n\n  set initial(value: TFormInput) {\n    this[state].initial = value;\n  }\n\n  get output() {\n    return this[state].output;\n  }\n\n  validate(): TFormOutput {\n    return atomic(() => {\n      this[state].errors = {};\n      this[state].output = this[state].validator(\n        cloneDeep(unwrap(this[state].values)),\n        (field, error, action = 'push') => {\n          if (!error) {\n            delete this[state].errors[field];\n            return;\n          }\n          this[state].errors[field] ||= [];\n          if (action === 'push') this[state].errors[field].push(error);\n          else if (action === 'unshift') this[state].errors[field].unshift(error);\n          else this[state].errors[field] = [error];\n        },\n      );\n      return unwrap(this[state].output);\n    });\n  }\n\n  get isValid() {\n    return derive(() => Object.keys(this[state].errors).length === 0);\n  }\n\n  field<TReturn>(\n    _path: unknown extends TFormInput ? string : never,\n  ): unknown extends TFormInput ? TypedKeckField<TReturn> : never;\n\n  field<TStringPath extends StringPath<TFormInput>>(\n    _path: unknown extends TFormInput ? never : TStringPath,\n  ): unknown extends TFormInput ? never : KeckFieldForPath<TFormInput, TStringPath>;\n\n  /**\n   * Returns a KeckField object for the given path. This can be used to access the field value,\n   * errors, and other state.\n   *\n   * By focusing (with Keck's `focus` method) this FormObserver, you can ensure the callback is only called upon\n   * changes to specific fields in the form.\n   *\n   * @param path The path to access.\n   */\n  field(path: string): any {\n    return peek(() => {\n      const value = get(this[state].values, path);\n      // TFormInput could be 'unknown', which KeckFieldArray and KeckFieldObject won't accept.\n      // But we know the type, and the field() method return type is explicit, so we can cast values as any to ignore TS errors.\n      if (Array.isArray(value))\n        return new KeckFieldArray(this as any, this[state] as any, path as any);\n      if (typeof value === 'object')\n        return new KeckFieldObject(this as any, this[state] as any, path as any);\n      return new KeckField(this, this[state], path as any);\n    });\n  }\n\n  focus(): this {\n    focus(this[state]);\n    return this;\n  }\n\n  /**\n   * Adds a callback that will be called when the form state changes. This returns a FormObserver\n   * object that can be used to observe specific fields in the form. E.g.:\n   *\n   * ```ts\n   * import { focus } from 'keck';\n   *\n   * const form = new KeckForm({ ... })\n   *\n   * // Add an observer callback\n   * const formObserver = form.observe(() => { console.log('form changed') });\n   *\n   * // Optional: \"focus\" the formObserver (using Keck's `focus` method) to ensure the callback is\n   * // only called upon changes to the specific properties accessed on this formObserver.\n   * // (If you don't call `focus`, the callback will be called on any change to the form state.)\n   * focus(formObserver);\n   * formObserver.field('name').value; // Access a property to observe changes to it\n   *\n   * // Changing a field value will trigger the callback:\n   * form.field('name').value = 'Jane'; // logs 'form changed'\n   * ```\n   */\n  observe(callback: () => void) {\n    return new KeckForm({ state: observe(this[state], callback) } as KeckFormOptionsInternal<\n      TFormInput,\n      TFormOutput\n    >);\n  }\n\n  get state() {\n    return this[state];\n  }\n}\n","import type React from 'react';\nimport { useRef } from 'react';\nimport { createContext } from 'react';\nimport { type FormValidatorFn, KeckForm } from './KeckForm';\nimport type { ObjectOrUnknown } from './types';\n\nexport type UseFormReturn<\n  TFormInput extends ObjectOrUnknown,\n  TFormOutput extends ObjectOrUnknown,\n> = {\n  form: KeckForm<TFormInput, TFormOutput>;\n  FormProvider: React.FC<{ children: React.ReactNode | React.ReactNode[] }>;\n};\n\nexport const keckFormContext = createContext<KeckForm<unknown, unknown> | null>(null);\n\nexport function useForm<TFormInput extends object, TFormOutput extends object>(options: {\n  initial: TFormInput;\n  validate: FormValidatorFn<TFormInput, TFormOutput>;\n}): UseFormReturn<TFormInput, TFormOutput> {\n  const formRef = useRef<UseFormReturn<TFormInput, TFormOutput>>(null);\n\n  if (!formRef.current) {\n    const form = new KeckForm<TFormInput, TFormOutput>({\n      initial: options.initial,\n      validate: options.validate,\n    });\n    const typedContext = keckFormContext as React.Context<KeckForm<TFormInput, TFormOutput> | null>;\n    formRef.current = {\n      form,\n      FormProvider: ({ children }) => {\n        return <typedContext.Provider value={form}>{children}</typedContext.Provider>;\n      },\n    };\n  }\n\n  return formRef.current;\n}\n","import { useObserver } from 'keck/react';\nimport { useContext, useRef } from 'react';\nimport { KeckForm, type KeckFormOptionsInternal } from './KeckForm';\nimport type { ObjectOrUnknown } from './types';\nimport { keckFormContext } from './useForm';\n\nexport function useFormContext<\n  TFormInput extends ObjectOrUnknown = unknown,\n  TFormOutput extends ObjectOrUnknown = unknown,\n>(): KeckForm<TFormInput, TFormOutput> {\n  const form = useContext(keckFormContext) as KeckForm<TFormInput, TFormOutput>;\n  if (!form) {\n    throw new Error('useFormContext must be used within a FormProvider.');\n  }\n\n  const state = useObserver(form.state);\n\n  const formRef = useRef<KeckForm<TFormInput, TFormOutput>>(null);\n  if (!formRef.current) {\n    formRef.current = new KeckForm({ state } as KeckFormOptionsInternal<TFormInput, TFormOutput>);\n  }\n\n  return formRef.current;\n}\n","import type { z } from 'zod';\nimport type { FormValidatorFn } from './KeckForm';\nimport type { StringPath } from './types';\n\nexport const zodValidator = <TInput extends object, TOutput extends object>(\n  schema: z.Schema<TOutput>,\n): FormValidatorFn<TInput, TOutput> => {\n  return (values, setError) => {\n    const result = schema.safeParse(values);\n    if (result.success) return result.data;\n\n    for (const error of result.error.errors) {\n      const path = error.path.join('.');\n      setError(path as StringPath<TInput>, error.message);\n    }\n\n    return null;\n  };\n};\n"],"names":["_get","_jsx"],"mappings":"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"}